package com.connectcv.coding.examples;

public class DataClass
{
    private int mIntValue;

    private String mStringValue;

    public int getIntValue()
    {
        return(mIntValue);
    }

    public String getStringValue()
    {
        return(mStringValue);
    }

    /**
     * <p>
     * <b>Do not</b> implement {@code equals()} unless it is unequivocal what equality means for a class. Equality and identity is
     * a very grey area, so it is best to avoid it altogether unless the situation is very clear.
     * </p>
     * <p>
     * If you implement {@code equals()} <b>you must</b> implement an equivalent {@link #hashCode()} method. See <i>Effective
     * Java</i> for more details.
     * </p>
     * <p>
     * Both the {@code equals()} and {@code hashCode()} methods can be generated by Eclipse. However, you will need to rename the
     * parameter for {@code equals()} to conform to standards.
     * </p>
     * <p>
     * If you do create the {@code equals(}) method by hand, use {@code instanceof} rather than comparing classes and use getters
     * where available, as this means that dynamically generated and test subclasses can still use the {@code equals()} method
     * (although determining equality where subclasses are involved is itself fraught with peril). Also, create a test method using
     * {@link au.com.tt.util.test.EqualityTester} to ensure that the {@code hashCode()} functions correctly.
     * </p>
     */
    @Override
    public boolean equals(Object inObject)
    {
        if (this == inObject) return(true);
        if (inObject == null) return(false);
        if (!(inObject instanceof DataClass)) return(false);
        final DataClass other = (DataClass) inObject;
        if (getIntValue() != other.getIntValue()) return(false);
        if (getStringValue() == null)
        {
            if (other.getStringValue() != null) return(false);
        }
        else if (!getStringValue().equals(other.getStringValue())) return(false);
        return(true);
    }

    /**
     * <p>
     * <b>Do not</b> implement {@code hashCode()} unless it is unequivocal what equality means for a class. Equality and identity
     * is a very grey area, so it is best to avoid it altogether unless the situation is very clear.
     * </p>
     * <p>
     * If you implement {@code hashCode()} <b>you must</b> implement an equivalent {@link #equals(Object)} method. See <i>Effective
     * Java</i> for more details.
     * </p>
     * <p>
     * Both the {@code hashCode()} and {@code equals()} methods can be generated by Eclipse. However, you will need to do fix the
     * return statement for {@code hashCode()} to conform to standards.
     * </p>
     * <p>
     * When generating the {@code hashCode(}) method, use getters where available, as this means that dynamically generated and
     * test subclasses can still use the {@code hasCode()} method.
     * </p>
     */
    @Override
    public int hashCode()
    {
        final int prime = 31;
        int result = 1;
        result = prime * result + getIntValue();
        result = prime * result + ((getStringValue() == null) ? 0 : getStringValue().hashCode());
        return(result);
    }
}